<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="LY Blog">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="LY Blog">
<meta property="og:locale" content="zh">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>LY Blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="bg_content">
    <canvas id="canvas"></canvas>
  </div>
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LY Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/15/RocketMQ/RocketMQ%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AOS%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E5%92%8CJVM%E5%8F%82%E6%95%B0%E7%9A%84%E8%B0%83%E6%95%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LY Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/15/RocketMQ/RocketMQ%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AOS%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E5%92%8CJVM%E5%8F%82%E6%95%B0%E7%9A%84%E8%B0%83%E6%95%B4/" class="post-title-link" itemprop="url">RocketMQ（五）：RocketMQ集群可视化监控和管理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-15 22:40:10" itemprop="dateCreated datePublished" datetime="2019-11-15T22:40:10+08:00">2019-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index">
                    <span itemprop="name">RocketMQ</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><h4 id="OS内核参数"><a href="#OS内核参数" class="headerlink" title="OS内核参数"></a>OS内核参数</h4><ul>
<li>vm.overcommit_memory<ul>
<li>配置含义<ul>
<li>0:中间件系统申请内存的时候，os内核会检查可用内存是否足够，如果足够的话就分配内存给你，如果感觉剩余内存不是太够了，干脆就拒绝你的申请，导致你申请内存失败，进而导致中间件系统异常出错。</li>
<li>1:把所有可用的物理内存都允许分配给你，只要有内存就给你来用，这样可以避免申请内存失败的问题。</li>
</ul>
</li>
<li>案例：我们曾经线上环境部署的Redis就因为这个参数是0，导致在save数据快照到磁盘文件的时候，需要申请大内存的时候被拒绝了，进而导致了异常报错。</li>
<li>修改：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;vm.overcommit_memory=1&apos; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>vm.max_map_count<ul>
<li>配置含义(默认：65536)<ul>
<li>这个参数的值会影响中间件系统可以开启的线程的数量，如果这个参数过小，有的时候可能会导致有些中间件无法开启足够的线程，进而导致报错，甚至中间件系统挂掉。</li>
</ul>
</li>
<li>修改（建议可以把这个参数调大10倍，比如655360这样的值，保证中间件可以开启足够多的线程）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;vm.max_map_count=655360&apos; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>vm.swappiness<ul>
<li>配置含义：这个参数是用来控制进程的swap行为的，这个简单来说就是os会把一部分磁盘空间作为swap区域，然后如果有的进程现在可能不是太活跃，就会被操作系统把进程调整为睡眠状态，把进程中的数据放入磁盘上的swap区域，然后让这个进程把原来占用的内存空间腾出来，交给其他活跃运行的进程来使用。<ul>
<li>0:尽量别把任何一个进程放到磁盘swap区域去，尽量大家都用物理内存。</li>
<li>100:尽量把一些进程给放到磁盘swap区域去，内存腾出来给活跃的进程使用。</li>
<li>60（默认）:有点偏高了，可能会导致我们的中间件运行不活跃的时候被迫腾出内存空间然后放磁盘swap区域去。</li>
</ul>
</li>
<li>修改：在生产环境建议把这个参数调整小一些，比如设置为10，尽量用物理内存，别放磁盘swap区域去。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;vm.swappiness=10&apos; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>ulimit<ul>
<li>配置含义<ul>
<li>这个是用来控制linux上的最大文件链接数的，默认值可能是1024，一般肯定是不够的，因为你在大量频繁的读写磁盘文件的时候，或者是进行网络通信的时候，都会跟这个参数有关系</li>
</ul>
</li>
<li>修改<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;ulimit -n 1000000&apos; &gt;&gt; /etc/profile</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>RocketMQ的JVM参数<ul>
<li>-Xms8g -Xmx8g -Xmn4g:重点需要调整的，就是默认的堆大小是8g内存，新生代是4g内存，但是我们的高配物理机是48g内存的，所以这里完全可以给他们翻几倍，比如给堆内存20g，其中新生代给10g，甚至可以更多一些，当然要留一些内存给操作系统来用。</li>
<li>-XX:+UseG1GC -XX:G1HeapRegionSize=16m：这几个参数也是至关重要的，这是选用了G1垃圾回收器来做分代回收，对新生代和老年代都是用G1来回收，这里把G1的region大小设置为了16m，这个因为机器内存比较多，所以region大小可以调大一些给到16m，不然用2m的region，会导致region数量过多的。</li>
<li>-XX:G1ReservePercent=25：这个参数是说，在G1管理的老年代里预留25%的空闲内存，保证新生代对象晋升到老年代的时候有足够空间，避免老年代内存都满了，新生代有对象要进入老年代没有充足内存了，默认值是10%，略微偏少，这里RocketMQ给调大了一些</li>
<li>-XX:InitiatingHeapOccupancyPercent=30：这个参数是说，当堆内存的使用率达到30%之后就会自动启动G1的并发垃圾回收，开始尝试回收一些垃圾对象，默认值是45%，这里调低了一些，也就是提高了GC的频率，但是避免了垃圾对象过多，一次垃圾回收耗时过长的问题。</li>
<li>-XX:SoftRefLRUPolicyMSPerMB=0：这个参数默认设置为0了，其实建议这个参数不要设置为0，避免频繁回收一些软引用的Class对象，这里可以调整为比如1000。</li>
<li>-verbose:gc -Xloggc:/dev/shm/mq_gc_%p.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintAdaptiveSizePolicy -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=30m：这一堆参数都是控制GC日志打印输出的，确定了gc日志文件的地址，要打印哪些详细信息，然后控制每个gc日志文件的大小是30m，最多保留5个gc日志文件。</li>
<li>-XX:-OmitStackTraceInFastThrow：这个参数是说，有时候JVM会抛弃一些异常堆栈信息，因此这个参数设置之后，就是禁用这个特性，要把完整的异常堆栈信息打印出来。</li>
<li>-XX:+AlwaysPreTouch：这个参数的意思是我们刚开始指定JVM用多少内存，不会真正分配给他，会在实际需要使用的时候再分配给他，所以使用这个参数之后，就是强制让JVM启动的时候直接分配我们指定的内存，不要等到使用内存的时候再分配</li>
<li>-XX:MaxDirectMemorySize=15g：这是说RocketMQ里大量用了NIO中的direct buffer，这里限定了direct buffer最多申请多少，如果你机器内存比较大，可以适当调大这个值。</li>
<li>-XX:-UseLargePages -XX:-UseBiasedLocking：这两个参数的意思是禁用大内存页和偏向锁，直接禁用两个特性即可。</li>
</ul>
</li>
<li>RocketMQ核心参数<ul>
<li>dledger的示例配置文件：rocketmq/distribution/target/apache-rocketmq/conf/dledger</li>
<li>sendMessageThreadPoolNums=16，这个参数的意思就是RocketMQ内部用来发送消息的线程池的线程数量，默认是16。这个参数可以根据你的机器的CPU核数进行适当增加，比如机器CPU是24核的，可以增加这个线程数量到24或者30。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/15/RocketMQ/RocketMQ%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9ARocketMQ%E9%9B%86%E7%BE%A4%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%91%E6%8E%A7%E5%92%8C%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LY Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/15/RocketMQ/RocketMQ%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9ARocketMQ%E9%9B%86%E7%BE%A4%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%91%E6%8E%A7%E5%92%8C%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">RocketMQ（五）：RocketMQ集群可视化监控和管理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-15 22:40:10" itemprop="dateCreated datePublished" datetime="2019-11-15T22:40:10+08:00">2019-11-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index">
                    <span itemprop="name">RocketMQ</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><h4 id="RocketMQ的大优势：可视化的管理界面"><a href="#RocketMQ的大优势：可视化的管理界面" class="headerlink" title="RocketMQ的大优势：可视化的管理界面"></a>RocketMQ的大优势：可视化的管理界面</h4><ul>
<li>NameServer的三台机器中的任意一台机器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/apache/rocketmq-externals.git</span><br><span class="line">cd rocketmq-externals/rocketmq-console</span><br><span class="line"># 执行以下命令对rocketmq-cosole进行打包，把他做成一个jar包：</span><br><span class="line">mvn package -DskipTests</span><br><span class="line"># 进入target目录下，可以看到一个jar包，接着执行下面的命令启动工作台：</span><br><span class="line">java -jar rocketmq-console-ng-1.0.1.jar --server.port=8080 --rocketmq.config.namesrvAddr=127.0.0.1:9876</span><br></pre></td></tr></table></figure>










</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/12/RocketMQ/RocketMQ%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9ARocketMQ%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LY Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/12/RocketMQ/RocketMQ%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9ARocketMQ%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">RocketMQ（四）：RocketMQ集群部署</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-12 21:05:24" itemprop="dateCreated datePublished" datetime="2019-11-12T21:05:24+08:00">2019-11-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index">
                    <span itemprop="name">RocketMQ</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><ul>
<li>安装JDK，同时要在环境变量中设置Java_HOME</li>
<li>进入apache-rocketmq目录，编辑三个文件，bin/runserver.sh，bin/runbroker.sh，bin/tools.sh。第二行和第三行都删了，同时将第一行的值修改为你自己的JDK的主目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ ! -e &quot;$JAVA_HOME/bin/java&quot; ] &amp;&amp; JAVA_HOME=$HOME/jdk/java</span><br><span class="line"></span><br><span class="line">[ ! -e &quot;$JAVA_HOME/bin/java&quot; ] &amp;&amp; JAVA_HOME=/usr/java</span><br><span class="line"></span><br><span class="line">[ ! -e &quot;$JAVA_HOME/bin/java&quot; ] &amp;&amp; error_exit &quot;Please set the JAVA_HOME variable in your environment, We need java(x64)!&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h4 id="单台机器快速部署RocketMQ"><a href="#单台机器快速部署RocketMQ" class="headerlink" title="单台机器快速部署RocketMQ"></a>单台机器快速部署RocketMQ</h4>  可以部署在三台机器上，这样可以充分保证NameServer作为路由中心的可用性，哪怕是挂掉两台机器，只要有一个NameServer还在运行，就能保证MQ系统的稳定性。<br>  每台NameServer实际上都会有完整的集群路由信息，包括所有的Broker节点信息，我们的数据信息，等等。所以只要任何一台NameServer存活下来，就可以保证MQ系统正常运行，不会出现故障。<ul>
<li>集群启动、关闭<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh bin/dledger/fast-try.sh start</span><br><span class="line">sh bin/dledger/fast-try.sh stop</span><br></pre></td></tr></table></figure>
这个命令会在当前这台机器上启动一个NameServer和三个Broker，三个Broker其中一个是Master，另外两个是Slave，瞬间就可以组成一个最小可用的RocketMQ集群。</li>
<li>sh bin/mqadmin clusterList -n 127.0.0.1:9876<br>检查一下RocketMQ集群的状态，三行记录，说是一个RaftCluster，Broker名称叫做RaftNode00，然后BID是0、1、2，也有可能是0、1、3。BID为0的就是Master，BID大于0的就都是Slave。</li>
<li>lsof -i:30921，找出来占用30921端口的进程PID，接着就用kill -9的命令给他杀了。</li>
<li>sh bin/mqadmin clusterList -n 127.0.0.1:9876<br>此时就会发现作为Leader的BID为0的节点，变成另外一个Broker了，这就是说Slave切换为Master了。</li>
</ul>
</li>
<li><h5 id="三台NameServer的部署"><a href="#三台NameServer的部署" class="headerlink" title="三台NameServer的部署"></a>三台NameServer的部署</h5><ul>
<li>nohup sh mqnamesrv &amp;<br>NameServer监听的接口默认是9876，所以在三台机器上都启动了NameServer，那么他们的端口都是9876，此时启动了三个NameServer。</li>
</ul>
</li>
<li><h5 id="一组Broker集群的部署"><a href="#一组Broker集群的部署" class="headerlink" title="一组Broker集群的部署"></a>一组Broker集群的部署</h5><ul>
<li>nohup sh bin/mqbroker -c conf/dledger/broker-n0.conf &amp;<br>第一个Broker的配置文件是broker-n0.conf，第二个broker的配置文件可以是Broker-n1.conf，第三个Broker的配置文件可以是broker-n2.conf。</li>
<li>broker-n0.conf配置详解<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 这个是集群的名称，你整个broker集群都可以用这个名称</span><br><span class="line">brokerClusterName = RaftCluster</span><br><span class="line"># 这是Broker的名称，比如你有一个Master和两个Slave，那么他们的Broker名称必须是一样的，因为他们三个是一个分组，如果你有另外一组Master和两个Slave，你可以给他们起个别的名字，比如说RaftNode01</span><br><span class="line">brokerName=RaftNode00</span><br><span class="line"># 这个就是你的Broker监听的端口号，如果每台机器上就部署一个Broker，可以考虑就用这个端口号，不用修改</span><br><span class="line">listenPort=30911</span><br><span class="line"># 这里是配置NameServer的地址，如果你有很多个NameServer的话，可以在这里写入多个NameServer的地址</span><br><span class="line">namesrvAddr=127.0.0.1:9876;127.0.0.2:9876;</span><br><span class="line"># 下面两个目录是存放Broker数据的地方，你可以换成别的目录，类似于是/usr/local/rocketmq/node00之类的</span><br><span class="line">storePathRootDir=/tmp/rmqstore/node00</span><br><span class="line">storePathCommitLog=/tmp/rmqstore/node00/commitlog</span><br><span class="line"># 这个是非常关键的一个配置，就是是否启用DLeger技术，这个必须是true</span><br><span class="line">enableDLegerCommitLog=true</span><br><span class="line"># 这个一般建议和Broker名字保持一致，一个Master加两个Slave会组成一个Group</span><br><span class="line">dLegerGroup=RaftNode00</span><br><span class="line"># 这个很关键，对于每一组Broker，你得保证他们的这个配置是一样的，在这里要写出来一个组里有哪几个Broker，比如在这里假设有三台机器部署了Broker，要让他们作为一个组，那么在这里就得写入他们三个的ip地址和监听的端口号</span><br><span class="line">dLegerPeers=n0-127.0.0.1:40911;n1-127.0.0.1:40912;n2-127.0.0.1:40913</span><br><span class="line"># 这个是代表了一个Broker在组里的id，一般就是n0、n1、n2之类的，这个你得跟上面的dLegerPeers中的n0、n1、n2相匹配</span><br><span class="line">dLegerSelfId=n0</span><br><span class="line"># 这个是发送消息的线程数量，一般建议你配置成跟你的CPU核数一样，比如我们的机器假设是24核的，那么这里就修改成24核</span><br><span class="line">sendMessageThreadPoolNums=24</span><br></pre></td></tr></table></figure></li>
<li>最关键的是，Broker是分为多组的，每一组是三个Broker，一个Master和两个Slave。对每一组Broker，他们的Broker名称、Group名称都是一样的，然后你得给他们配置好一样的dLegerPeers（里面是组内三台Broker的地址）。然后他们得配置好对应的NameServer的地址，最后还有就是每个Broker有自己的ID，在组内是唯一的就可以了，比如说不同的组里都有一个ID为n0的Broker。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/11/RocketMQ/RocketMQ%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%94%9F%E4%BA%A7%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LY Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/11/RocketMQ/RocketMQ%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%94%9F%E4%BA%A7%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">RocketMQ（三）：高可用的消息中间件生产部署架构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-11 21:05:24" itemprop="dateCreated datePublished" datetime="2019-11-11T21:05:24+08:00">2019-11-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index">
                    <span itemprop="name">RocketMQ</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><h4 id="NameServer集群化部署，保证高可用性"><a href="#NameServer集群化部署，保证高可用性" class="headerlink" title="NameServer集群化部署，保证高可用性"></a>NameServer集群化部署，保证高可用性</h4><ul>
<li>可以部署在三台机器上，这样可以充分保证NameServer作为路由中心的可用性，哪怕是挂掉两台机器，只要有一个NameServer还在运行，就能保证MQ系统的稳定性。</li>
<li>每台NameServer实际上都会有完整的集群路由信息，包括所有的Broker节点信息，我们的数据信息，等等。所以只要任何一台NameServer存活下来，就可以保证MQ系统正常运行，不会出现故障。</li>
</ul>
</li>
<li><h4 id="基于Dledger的Broker主从架构部署（RocketMQ-4-5以后）"><a href="#基于Dledger的Broker主从架构部署（RocketMQ-4-5以后）" class="headerlink" title="基于Dledger的Broker主从架构部署（RocketMQ 4.5以后）"></a>基于Dledger的Broker主从架构部署（RocketMQ 4.5以后）</h4><ul>
<li>Dledger技术是要求至少得是一个Master带两个Slave，这样有三个Broke组成一个Group，也就是作为一个分组来运行。一旦Master宕机，他就可以从剩余的两个Slave中选举出来一个新的Master对外提供服务。</li>
<li>每个Broker（不论是Master和Slave）都会把自己注册到所有的NameServer上去。（* 注：图中没有画出Slave Broker注册到NameServer）<br><img src="https://s2.ax1x.com/2019/11/13/MYQVpT.png" alt="avatar"></li>
</ul>
</li>
<li><h4 id="Broker是如何跟NameServer进行通信的？"><a href="#Broker是如何跟NameServer进行通信的？" class="headerlink" title="Broker是如何跟NameServer进行通信的？"></a>Broker是如何跟NameServer进行通信的？</h4><ul>
<li>Broker会跟每个NameServer都建立一个TCP长连接，然后定时通过TCP长连接发送心跳请求过去。</li>
<li>各个NameServer就是通过跟Broker建立好的长连接不断收到心跳包，然后定时检查Broker有没有120s都没发送心跳包，来判定集群里各个Broker到底挂掉了没有。</li>
</ul>
</li>
<li><h4 id="使用MQ的系统都要多机器集群部署"><a href="#使用MQ的系统都要多机器集群部署" class="headerlink" title="使用MQ的系统都要多机器集群部署"></a>使用MQ的系统都要多机器集群部署</h4><ul>
<li>生产者还是消费者的系统，都应该多机器集群化部署，保证他自己本身作为生产者或者消费者的高可用性。</li>
</ul>
</li>
<li><h4 id="MQ的核心数据模型：Topic（数据集合）"><a href="#MQ的核心数据模型：Topic（数据集合）" class="headerlink" title="MQ的核心数据模型：Topic（数据集合）"></a>MQ的核心数据模型：Topic（数据集合）</h4><ul>
<li>作为数据集合存放不同类型的消息，比如说订单Topic，商品Topic，等等。</li>
</ul>
</li>
<li><h4 id="Topic作为一个数据集合是怎么在Broker集群里存储的？（分布式存储）"><a href="#Topic作为一个数据集合是怎么在Broker集群里存储的？（分布式存储）" class="headerlink" title="Topic作为一个数据集合是怎么在Broker集群里存储的？（分布式存储）"></a>Topic作为一个数据集合是怎么在Broker集群里存储的？（分布式存储）</h4><ul>
<li>创建Topic的时候指定让他里面的数据分散存储在多台Broker机器上，比如一个Topic里有1000万条数据，此时有2台Broker，那么就可以让每台Broker上都放500万条数据。</li>
<li>每个Broker在进行定时的心跳汇报给NameServer的时候，都会告诉NameServer自己当前的数据情况，比如有哪些Topic的哪些数据在自己这里，这些信息都是属于路由信息的一部分。<br><img src="https://s2.ax1x.com/2019/11/14/MYIJGd.png" alt="avatar"></li>
</ul>
</li>
<li><h4 id="生产者系统是如何将消息发送给Broker的？"><a href="#生产者系统是如何将消息发送给Broker的？" class="headerlink" title="生产者系统是如何将消息发送给Broker的？"></a>生产者系统是如何将消息发送给Broker的？</h4><ul>
<li>在发送消息之前，得先有一个Topic，然后在发送消息的时候，得指定你要发送到哪个Topic里面去。</li>
<li>跟NameServer建立一个TCP长连接，然后定时从他那里拉取到最新的路由信息，包括集群里有哪些Broker，集群里有哪些Topic，每个Topic都存储在哪些Broker上。</li>
<li>生产者系统自然就可以通过路由信息找到自己要投递消息的Topic分布在哪几台Broker上，此时可以根据负载均衡算法，从里面选择一台Broke机器出来，比如round robine轮询算法，或者是hash算法，都可以。Broker收到消息之后就会存储在自己本地磁盘里去。</li>
<li>生产者一定是投递消息到Master Broker的，然后Master Broker会同步数据给他的Slave Brokers，实现一份数据多份副本，保证Master故障的时候数据不丢失，而且可以自动把Slave切换为Master提供服务。<br><img src="https://s2.ax1x.com/2019/11/14/MtfZqO.png" alt="avatar"></li>
</ul>
</li>
<li><h4 id="消费者是如何从Broker上拉取消息的？"><a href="#消费者是如何从Broker上拉取消息的？" class="headerlink" title="消费者是如何从Broker上拉取消息的？"></a>消费者是如何从Broker上拉取消息的？</h4><ul>
<li>消费者系统其实跟生产者系统原理是类似的，他们也会跟NameServer建立长连接，然后拉取路由信息，接着找到自己要获取消息的Topic在哪几台Broker上，就可以跟Broker建立长连接，从里面拉取消息了。</li>
<li>消费者系统可能会从Master Broker拉取消息，也可能从Slave Broker拉取消息，都有可能。<br><img src="https://s2.ax1x.com/2019/11/14/Mtfzlt.png" alt="avatar"></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/09/RocketMQ/RocketMQ%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ABroker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LY Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/RocketMQ/RocketMQ%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ABroker/" class="post-title-link" itemprop="url">RocketMQ（二）：Broker的主从架构原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-09 20:40:10" itemprop="dateCreated datePublished" datetime="2019-11-09T20:40:10+08:00">2019-11-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index">
                    <span itemprop="name">RocketMQ</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><h4 id="Master-Broker是如何将消息同步给Slave-Broker的？"><a href="#Master-Broker是如何将消息同步给Slave-Broker的？" class="headerlink" title="Master Broker是如何将消息同步给Slave Broker的？"></a>Master Broker是如何将消息同步给Slave Broker的？</h4><ul>
<li>为了保证MQ的数据不丢失而且具备一定的高可用性，所以一般都是得将Broker部署成Master-Slave模式的，也就是一个Master Broker对应一个Slave Broker。然后Master需要在接收到消息之后，将数据同步给Slave，这样一旦Master Broker挂了，还有Slave上有一份数据。</li>
<li>RocketMQ的Master-Slave模式采取的是Slave Broker不停的发送请求到Master Broker去拉取消息。<br><img src="https://s2.ax1x.com/2019/11/13/MYnnoV.png" alt="avatar"></li>
</ul>
</li>
<li><h4 id="RocketMQ-实现读写分离了吗？"><a href="#RocketMQ-实现读写分离了吗？" class="headerlink" title="RocketMQ 实现读写分离了吗？"></a>RocketMQ 实现读写分离了吗？</h4><ul>
<li>有可能从Master Broker获取消息，也有可能从Slave Broker获取消息。</li>
<li>作为消费者的系统在获取消息的时候会先发送请求到Master Broker上去，请求获取一批消息，此时Master Broker是会返回一批消息给消费者系统的。然后Master Broker在返回消息给消费者系统的时候，会根据当时Master Broker的负载情况和Slave Broker的同步情况，向消费者系统建议下一次拉取消息的时候是从Master Broker拉取还是从Slave Broker拉取。</li>
</ul>
</li>
<li><h4 id="如果Slave-Broke挂掉了有什么影响？"><a href="#如果Slave-Broke挂掉了有什么影响？" class="headerlink" title="如果Slave Broke挂掉了有什么影响？"></a>如果Slave Broke挂掉了有什么影响？</h4><ul>
<li>因为消息写入全部是发送到Master Broker的，然后消息获取也可以走Master Broker，只不过有一些消息获取可能是从Slave Broker去走的。所以如果Slave Broker挂了，那么此时无论消息写入还是消息拉取，还是可以继续从Master Broke去走，对整体运行不影响。</li>
</ul>
</li>
<li><h4 id="如果Master-Broker挂掉了该怎么办？"><a href="#如果Master-Broker挂掉了该怎么办？" class="headerlink" title="如果Master Broker挂掉了该怎么办？"></a>如果Master Broker挂掉了该怎么办？</h4><ul>
<li>RocketMQ 4.5版本之前，都是用Slave Broker同步数据，尽量保证数据不丢失，但是一旦Master故障了，Slave是没法自动切换成Master的。</li>
<li>如果Master Broker宕机了，这时就得手动做一些运维操作，把Slave Broker重新修改一些配置，重启机器给调整为Master Broker。</li>
<li>Master-Slave模式不是彻底的高可用模式，他没法实现自动把Slave切换为Master</li>
</ul>
</li>
<li><h4 id="基于Dledger实现RocketMQ高可用自动切换（RocketMQ-4-5之后）"><a href="#基于Dledger实现RocketMQ高可用自动切换（RocketMQ-4-5之后）" class="headerlink" title="基于Dledger实现RocketMQ高可用自动切换（RocketMQ 4.5之后）"></a>基于Dledger实现RocketMQ高可用自动切换（RocketMQ 4.5之后）</h4><ul>
<li>把Dledger融入RocketMQ之后，就可以让一个Master Broker对应多个Slave Broker，也就是说一份数据可以有多份副本，比如一个Master Broker对应两个Slave Broker。</li>
<li>Master Broker宕机了，就可以在多个副本，也就是多个Slave中，通过Dledger技术和Raft协议算法进行leader选举，直接将一个Slave Broker选举为新的Master Broker，然后这个新的Master Broker就可以对外提供服务了。<br><img src="https://s2.ax1x.com/2019/11/13/MYMNoq.png" alt="avatar"></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/07/RocketMQ/RocketMQ%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%B0%8F%E8%A7%84%E6%A8%A1RocketMQ%E9%9B%86%E7%BE%A4%E8%BF%9B%E8%A1%8C%E5%8E%8B%E6%B5%8B%EF%BC%8C%E5%90%8C%E6%97%B6%E4%B8%BA%E7%94%9F%E4%BA%A7%E9%9B%86%E7%BE%A4%E8%BF%9B%E8%A1%8C%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LY Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/07/RocketMQ/RocketMQ%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%B0%8F%E8%A7%84%E6%A8%A1RocketMQ%E9%9B%86%E7%BE%A4%E8%BF%9B%E8%A1%8C%E5%8E%8B%E6%B5%8B%EF%BC%8C%E5%90%8C%E6%97%B6%E4%B8%BA%E7%94%9F%E4%BA%A7%E9%9B%86%E7%BE%A4%E8%BF%9B%E8%A1%8C%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">RocketMQ（一）：NameServer</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-07 19:34:14" itemprop="dateCreated datePublished" datetime="2019-11-07T19:34:14+08:00">2019-11-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index">
                    <span itemprop="name">RocketMQ</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><h4 id="RocketMQ小规模集群的压测"><a href="#RocketMQ小规模集群的压测" class="headerlink" title="RocketMQ小规模集群的压测"></a>RocketMQ小规模集群的压测</h4><ul>
<li>RocketMQ的TPS和消息延时<ul>
<li>两个Producer不停的往RocketMQ集群发送消息，每个Producer所在机器启动了80个线程，相当于每台机器有80个线程并发的往RocketMQ集群写入消息。RocketMQ集群是1主2从组成的一个dledger模式的高可用集群，只有一个Master Broker会接收消息的写入。有2个Cosumer不停的从RocketMQ集群消费数据。</li>
<li>每条数据的大小是500个字节。一条消息从Producer生产出来到经过RocketMQ的Broker存储下来，再到被Consumer消费，基本上这个时间跨度不会超过1秒钟，这些这个性能是正常而且可以接受的。</li>
<li>同时在RocketMQ的管理工作台中可以看到，Master Broker的TPS（也就是每秒处理消息的数量），可以稳定的达到7万左右，也就是每秒可以稳定处理7万消息。</li>
</ul>
</li>
<li>cpu负载情况<ul>
<li>执行top命令就可以看到cpu load和cpu使用率，这就代表了cpu的负载情况。</li>
<li>执行了top命令之后，往往可以看到如下一行信息：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load average：12.03，12.05，12.08</span><br><span class="line">类似上面那行信息代表的是cpu在1分钟、5分钟和15分钟内的cpu负载情况</span><br></pre></td></tr></table></figure>
  比如我们一台机器是24核的，那么上面的12意思就是有12个核在使用中。换言之就是还有12个核其实还没使用，cpu还是有很大余力的。</li>
</ul>
</li>
<li>内存使用率<ul>
<li>使用free命令就可以查看到内存的使用率</li>
</ul>
</li>
<li>JVM GC频率<ul>
<li>使用jstat命令就可以查看RocketMQ的JVM的GC频率，基本上新生代每隔几十秒会垃圾回收一次，每次回收过后存活的对象很少，几乎不进入老年代</li>
</ul>
</li>
<li>磁盘IO负载<ul>
<li>用top命令查看一下IO等待占用CPU时间的百分比<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cpu(s):  0.3% us,  0.3% sy,  0.0% ni, 76.7% id, 13.2% wa,  0.0% hi,  0.0% si。</span><br></pre></td></tr></table></figure>
在这里的13.2% wa，说的就是磁盘IO等待在CPU执行时间中的百分比，如果这个比例太高，说明CPU执行的时候大部分时间都在等待执行IO，也就说明IO负载很高，导致大量的IO等待。如果是40%左右，说明IO等待时间占用CPU执行时间的比例在40%左右，这是相对高一些，但还是可以接受的，只不过如果继续让这个比例提高上去，就很不靠谱了，因为说明磁盘IO负载可能过高了。</li>
</ul>
</li>
<li>网卡流量  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -n DEV 1 2</span><br></pre></td></tr></table></figure>
<ul>
<li>服务器使用的是千兆网卡，千兆网卡的理论上限是每秒传输128M数据，但是一般实际最大值是每秒传输100M数据。</li>
<li>在RocketMQ处理到每秒7万消息的时候，每条消息500字节左右的大小的情况下，每秒网卡传输数据量已经达到100M了，就是已经达到了网卡的一个极限值了。</li>
<li>因为一个Master Broker服务器，每秒不光是通过网络接收你写入的数据，还要把数据同步给两个Slave Broker，还有别的一些网络通信开销。因此实际压测发现，每条消息500字节，每秒7万消息的时候，服务器的网卡就几乎打满了，无法承载更多的消息了。</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/07/RocketMQ/RocketMQ%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ANameServer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LY Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/07/RocketMQ/RocketMQ%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ANameServer/" class="post-title-link" itemprop="url">RocketMQ（一）：NameServer</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-07 19:34:14" itemprop="dateCreated datePublished" datetime="2019-11-07T19:34:14+08:00">2019-11-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index">
                    <span itemprop="name">RocketMQ</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><h4 id="RocketMQ整体架构图"><a href="#RocketMQ整体架构图" class="headerlink" title="RocketMQ整体架构图"></a>RocketMQ整体架构图</h4><ul>
<li><h5 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h5>负责去管理集群里所有Broker的信息，让使用MQ的系统可以通过他感知到集群里有哪些Broker。</li>
<li><h5 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h5>Broker集群，必须得在多台机器上部署这么一个集群，而且还得用主从架构实现数据多副本存储和高可用。</li>
<li><h5 id="ProducerClient"><a href="#ProducerClient" class="headerlink" title="ProducerClient"></a>ProducerClient</h5>用户部署的消息发布客户端。</li>
<li><h5 id="ConsumerClient"><a href="#ConsumerClient" class="headerlink" title="ConsumerClient"></a>ConsumerClient</h5>用户部署的消息订阅客户端。支持push和pull模型，支持广播模式和集群模式。<br><img src="https://s2.ax1x.com/2019/11/06/MCwFtP.png" alt="avatar"></li>
</ul>
</li>
<li><h4 id="NameServer部署、注册、获取"><a href="#NameServer部署、注册、获取" class="headerlink" title="NameServer部署、注册、获取"></a>NameServer部署、注册、获取</h4><ul>
<li>多台服务器部署NameServer，保证高可用。</li>
<li>每个Broker启动都得向所有的NameServer进行注册，个NameServer都会有一份集群中所有Broker的信息。</li>
<li>生产者和消费者自己每隔一段时间，定时发送请求到NameServer去拉取最新的集群Broker信息。路由信息，每个系统就知道发送消息或者获取消息去哪台Broker上去进行了，这起到一个把消息路由到一个Broker上的效果，所以一般我们把这种信息叫做路由信息。</li>
</ul>
</li>
<li><h4 id="如果Broker挂了，NameServer是怎么感知到的？"><a href="#如果Broker挂了，NameServer是怎么感知到的？" class="headerlink" title="如果Broker挂了，NameServer是怎么感知到的？"></a>如果Broker挂了，NameServer是怎么感知到的？</h4><ul>
<li><strong>30s心跳机制：</strong> Broker跟NameServer之间的心跳机制，Broker会每隔30s给所有的NameServer发送心跳，告诉每个NameServer自己目前还活着。</li>
<li><strong>120s故障感知机制：</strong> NameServer会每隔10s运行一个任务，去检查一下各个Broker的最近一次心跳时间，如果某个Broker超过120s都没发送心跳了，那么就认为这个Broker已经挂掉了。</li>
</ul>
</li>
<li><h4 id="Broker挂了，系统是怎么感知到的？"><a href="#Broker挂了，系统是怎么感知到的？" class="headerlink" title="Broker挂了，系统是怎么感知到的？"></a>Broker挂了，系统是怎么感知到的？</h4><ul>
<li><strong>ProducerClient容错机制</strong><ul>
<li>改成发到其他Broker上去</li>
<li>与宕机的slave备份机器通信</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>  核心：集群化部署、Broker会注册到所有NameServer去、30s心跳机制和120s故障感知机制、生产者和消费者的客户端容错机制</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%E9%A1%B9%E7%9B%AE%E8%AE%A1%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LY Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%E9%A1%B9%E7%9B%AE%E8%AE%A1%E5%88%92/" class="post-title-link" itemprop="url">软件工程管理（三）项目计划</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-03 20:50:00" itemprop="dateCreated datePublished" datetime="2019-05-03T20:50:00+08:00">2019-05-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SoftwareManage/" itemprop="url" rel="index">
                    <span itemprop="name">SoftwareManage</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><h4 id="制定项目计划，三个基本步骤："><a href="#制定项目计划，三个基本步骤：" class="headerlink" title="制定项目计划，三个基本步骤："></a>制定项目计划，三个基本步骤：</h4><ul>
<li>任务分解<ul>
<li>大的阶段分成技术方案设计、编码和测试，然后每一个大的阶段下面再进一步细分。</li>
<li>例如技术方案设计下面再有需求分析、技术方案设计和评审等；而编码阶段则是按照功能模块再进一步拆分。拆分之后，都是小而具体、可交付结果的任务，且不能再进一步拆分。</li>
</ul>
</li>
<li>估算时间<ul>
<li>任务拆分的越细致，想的越清楚，就能估算的越准确。</li>
<li>要让负责这个任务的人员参与估算。</li>
</ul>
</li>
<li>排任务路径<ul>
<li>排路径就是要根据任务之间的关系，资源的占用情况，排出合适的顺序</li>
<li>排路径是一个相对比较复杂的任务，比如要注意任务的依赖关系，要注意路径的长度，尽可能让几个任务可以并行的进行，避免相互等待。</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="设置里程碑"><a href="#设置里程碑" class="headerlink" title="设置里程碑"></a>设置里程碑</h4><ul>
<li>里程碑的时间点确定后，计划可以灵活调整，但里程碑一般不会轻易改变，因为里程碑代表着一份承诺。这对于项目成员来说，有两个重要的影响，一方面，成员会有很明显的来自 DeadLine 的进度压力，自古 DeadLine 就是第一生产力；另一方面，就是在里程碑完成后，大家会获得一种正面激励。</li>
</ul>
</li>
<li><h4 id="计划跟踪和调整"><a href="#计划跟踪和调整" class="headerlink" title="计划跟踪和调整"></a>计划跟踪和调整</h4><ul>
<li>跟踪进度的方式<ul>
<li>项目经理定期收集跟踪：有一个沟通确认的过程，对进度会了解的更准确。</li>
<li>项目成员主动汇报：可以减少项目经理的收集工作，但有可能不准确。</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LY Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">软件工程管理（二）敏捷开发</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-03 20:11:08" itemprop="dateCreated datePublished" datetime="2019-05-03T20:11:08+08:00">2019-05-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SoftwareManage/" itemprop="url" rel="index">
                    <span itemprop="name">SoftwareManage</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><h4 id="什么是敏捷开发"><a href="#什么是敏捷开发" class="headerlink" title="什么是敏捷开发"></a>什么是敏捷开发</h4>  敏捷不是一种方法论，也不是一种软件开发的具体方法，更不是一个框架或过程，而是一套价值观和原则。<br>  用敏捷开发的方式，不再像瀑布模型那样有严格的阶段划分，会在迭代中不断完善；不再写很多文档，而是和客户一起紧密合作；不再抵制需求变更，而是即时响应变更；不再等到测试阶段才发布，而是随时发布，客户随时可以看到东西。<br>  敏捷开发的模式也存在一些问题，例如全程需要客户参与，由于测试相对少一些 ，问题也会相应多一些。</li>
<li><h4 id="敏捷开发和瀑布模型的差异"><a href="#敏捷开发和瀑布模型的差异" class="headerlink" title="敏捷开发和瀑布模型的差异"></a>敏捷开发和瀑布模型的差异</h4><ul>
<li>敏捷开发是怎么做需求分析的<ul>
<li>瀑布模型的一个重要阶段就是需求分析，要有严谨的需求分析，产生详尽的需求分析文档。</li>
<li>而敏捷开发的需求，主要是来源于一个个小的用户故事，用户故事通常是写在卡片上的一句话，在 Sprint 的开发中，再去确认需求的细节。</li>
<li>好处是减少了大量需求文档的撰写，可以早些进入开发。但这个对开发人员在需求理解和沟通的能力上要求更高了。</li>
</ul>
</li>
<li>敏捷开发是怎么做架构设计的<ul>
<li>瀑布模型在需求分析完了以后，就需要根据需求做架构设计。</li>
<li>而在敏捷开发中，并不是基于完整的用户需求开发，每个 Sprint 只做一部分需求，所以是一种渐进式的架构设计，当前 Sprint 只做适合当前需求的架构设计。</li>
<li>这种渐进式的架构设计，迭代次数一多，就会出现架构满足不了需求的现象，产生不少冗余代码，通常我们叫它技术债务，需要定期对系统架构进行重构。</li>
</ul>
</li>
<li>敏捷开发怎么保证项目质量的<ul>
<li>瀑布模型在编码完成后，会有专门的阶段进行测试，以保证质量。</li>
<li>在敏捷开发的 Sprint 中，并没有专门的测试阶段，这就依赖于开发功能的同时，要编写单元测试和集成测试代码，用自动化的方式辅助完成测试。</li>
</ul>
</li>
<li>敏捷开发是怎么发布部署的<ul>
<li>瀑布模型通常在编码结束后，开始部署测试环境，然后在测试阶段定期部署测试环境。测试验收通过后，发布部署到生产环境。</li>
<li>在敏捷开发中，这种持续构建、持续发布的概念叫持续集成，因为整个过程都是全自动化的，每次完成一个任务，提交代码后都可以触发一次构建部署操作，脚本会拿最新的代码做一次全新的构建，然后运行所有的单元测试和集成测试代码，测试通过后部署到测试环境。</li>
</ul>
</li>
<li><h4 id="敏捷开发的-Sprint-和迭代模型的迭代有什么区别"><a href="#敏捷开发的-Sprint-和迭代模型的迭代有什么区别" class="headerlink" title="敏捷开发的 Sprint 和迭代模型的迭代有什么区别"></a>敏捷开发的 Sprint 和迭代模型的迭代有什么区别</h4><ul>
<li>我们假设有两个团队，都要实现一个简单的用户系统，一个团队用迭代模型，一个团队用敏捷开发（Scrum），一个迭代 /Sprint 的时间周期都是 2 周（10 个工作日）。</li>
<li>迭代模型所在的团队，产品经理会先花 2 天时间去分析需求，写成需求分析文档，架构师会花 3 天时间来做设计，程序员会花 3 天时间编码，测试再花 2 天时间去测试，最后上线用户系统。</li>
<li>敏捷开发的团队，产品经理会把需求拆分成了几个简单的用户故事：用户登录、用户注册、找回密码、修改资料，然后放到当前 Sprint 的 Backlog（任务清单），Team（开发团队）成员开始从 Backlog 选择用户故事。<ul>
<li>程序员 A 选了“用户登录”这个用户故事，他会去找产品经理确认需求细节，之后动手实现这个用户故事。</li>
<li>功能完成后，同时程序员 A 还写了单元测试代码和集成测试代码，对登录的功能写了自动化测试。完成后，通过持续集成工具测试和部署到测试环境。部署完成后，用户登录功能就可以进行使用了。</li>
<li>这个过程，程序员 A 可能花了 4 天时间，做完“用户登录”这个用户故事之后，他又开始继续选取“找回密码”的用户故事来做，4 天时间也完成了。</li>
<li>其他程序员也和程序员 A 一样，他们也会从 Backlog 选择一些用户故事来做。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LY Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">软件工程管理（一）瀑布模型</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-02 00:34:14" itemprop="dateCreated datePublished" datetime="2019-05-02T00:34:14+08:00">2019-05-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SoftwareManage/" itemprop="url" rel="index">
                    <span itemprop="name">SoftwareManage</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><h4 id="瀑布模型把整个项目过程分成了六个主要阶段"><a href="#瀑布模型把整个项目过程分成了六个主要阶段" class="headerlink" title="瀑布模型把整个项目过程分成了六个主要阶段"></a>瀑布模型把整个项目过程分成了六个主要阶段</h4><ul>
<li>问题的定义及规划<br>需求方和开发方共同确定软件开发目标，同时还要做可行性研究，以确定项目可行。这个阶段会产生需求文档和可行性研究报告。</li>
<li>需求分析<br>对需求方提出的所有需求，进行详细的分析。这个阶段一般需要和客户反复确认，以保证能充分理解客户需求。最终会形成需求分析文档。</li>
<li>软件设计<br>根据需求分析的结果，对整个软件系统进行抽象和设计，如系统框架设计，数据库设计等等。最后会形成架构设计文档。</li>
<li>程序编码<br>将架构设计和界面设计的结果转换成计算机能运行的程序代码。</li>
<li>软件测试<br>对可运行的结果对照需求分析文档进行严密的测试。</li>
<li>运行维护<br>在软件开发完成，正式运行投入使用。后续需要继续维护，修复错误和增加功能。交付时需要提供使用说明文档。</li>
</ul>
</li>
<li><h4 id="瀑布模型优点"><a href="#瀑布模型优点" class="headerlink" title="瀑布模型优点"></a>瀑布模型优点</h4><ul>
<li>简单易行</li>
<li>可以按照阶段检查，能及时发现问题</li>
<li>前一个阶段完成后，就可以重点关注下一个阶段</li>
<li>有很好的分工协作</li>
<li>对质量有保证</li>
</ul>
</li>
<li><h4 id="瀑布模型缺点"><a href="#瀑布模型缺点" class="headerlink" title="瀑布模型缺点"></a>瀑布模型缺点</h4><ul>
<li>难以响应需求的变更，当需求发生改变的时候，越到后期代价越大</li>
<li>工作量分布不均匀。例如前期开发，测试人员无法参与，而后期开发，测试人员又特别忙</li>
<li>前期进度受阻，会一只压缩后续阶段时间，导致延期或影响质量</li>
<li>一直到最后阶段才能看到结果</li>
</ul>
</li>
<li><h4 id="瀑布模型以外的开发模型"><a href="#瀑布模型以外的开发模型" class="headerlink" title="瀑布模型以外的开发模型"></a>瀑布模型以外的开发模型</h4><ul>
<li>快速开发快速改：先迅速建造一个可以运行的软件原型，然后收集用户反馈，再反复修改确认</li>
<li>大瀑布拆小瀑布：系统进行模块化处理，分批次交付软件产品</li>
<li>迭代模型：每次迭代都有一个可用的版本</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="刘勇"
    src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">刘勇</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘勇</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  


















  

  

  


  <script type="text/javascript" src="/js/src/dynamic_bg.js"></script>
  <script src="/lib/live2d/L2Dwidget.min.js"></script>
<script type="text/javascript">
  L2Dwidget.init({
    model: {
      jsonPath: '/lib/live2d/tororo/assets/tororo.model.json',
    },
    display: {
      superSample: 2,
      width: 100,
      height: 100,
      position: 'right',
      hOffset: 0,
      vOffset: 0,
    },
    mobile: {
      show: true,
      scale: 1,
      motion: true,
    },
    react: {
      opacityDefault: 0.8,
      opacityOnHover: 0.2,
    }
  })
</script>

</body>
</html>
