<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="LY Blog">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="LY Blog">
<meta property="og:locale" content="zh">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>LY Blog</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="bg_content">
    <canvas id="canvas"></canvas>
  </div>
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LY Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/12/RocketMQ/RocketMQ%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9ARocketMQ%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LY Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/12/RocketMQ/RocketMQ%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9ARocketMQ%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">RocketMQ（四）：RocketMQ集群部署</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-12 21:05:24" itemprop="dateCreated datePublished" datetime="2019-11-12T21:05:24+08:00">2019-11-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index">
                    <span itemprop="name">RocketMQ</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><ul>
<li>安装JDK，同时要在环境变量中设置Java_HOME</li>
<li>进入apache-rocketmq目录，编辑三个文件，bin/runserver.sh，bin/runbroker.sh，bin/tools.sh。第二行和第三行都删了，同时将第一行的值修改为你自己的JDK的主目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ ! -e &quot;$JAVA_HOME/bin/java&quot; ] &amp;&amp; JAVA_HOME=$HOME/jdk/java</span><br><span class="line"></span><br><span class="line">[ ! -e &quot;$JAVA_HOME/bin/java&quot; ] &amp;&amp; JAVA_HOME=/usr/java</span><br><span class="line"></span><br><span class="line">[ ! -e &quot;$JAVA_HOME/bin/java&quot; ] &amp;&amp; error_exit &quot;Please set the JAVA_HOME variable in your environment, We need java(x64)!&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><h4 id="单台机器快速部署RocketMQ"><a href="#单台机器快速部署RocketMQ" class="headerlink" title="单台机器快速部署RocketMQ"></a>单台机器快速部署RocketMQ</h4>  可以部署在三台机器上，这样可以充分保证NameServer作为路由中心的可用性，哪怕是挂掉两台机器，只要有一个NameServer还在运行，就能保证MQ系统的稳定性。<br>  每台NameServer实际上都会有完整的集群路由信息，包括所有的Broker节点信息，我们的数据信息，等等。所以只要任何一台NameServer存活下来，就可以保证MQ系统正常运行，不会出现故障。<ul>
<li>集群启动、关闭<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh bin/dledger/fast-try.sh start</span><br><span class="line">sh bin/dledger/fast-try.sh stop</span><br></pre></td></tr></table></figure>
这个命令会在当前这台机器上启动一个NameServer和三个Broker，三个Broker其中一个是Master，另外两个是Slave，瞬间就可以组成一个最小可用的RocketMQ集群。</li>
<li>sh bin/mqadmin clusterList -n 127.0.0.1:9876<br>检查一下RocketMQ集群的状态，三行记录，说是一个RaftCluster，Broker名称叫做RaftNode00，然后BID是0、1、2，也有可能是0、1、3。BID为0的就是Master，BID大于0的就都是Slave。</li>
<li>lsof -i:30921，找出来占用30921端口的进程PID，接着就用kill -9的命令给他杀了。</li>
<li>sh bin/mqadmin clusterList -n 127.0.0.1:9876<br>此时就会发现作为Leader的BID为0的节点，变成另外一个Broker了，这就是说Slave切换为Master了。</li>
</ul>
</li>
<li><h5 id="三台NameServer的部署"><a href="#三台NameServer的部署" class="headerlink" title="三台NameServer的部署"></a>三台NameServer的部署</h5><ul>
<li>nohup sh mqnamesrv &amp;<br>NameServer监听的接口默认是9876，所以在三台机器上都启动了NameServer，那么他们的端口都是9876，此时启动了三个NameServer。</li>
</ul>
</li>
<li><h5 id="一组Broker集群的部署"><a href="#一组Broker集群的部署" class="headerlink" title="一组Broker集群的部署"></a>一组Broker集群的部署</h5><ul>
<li>nohup sh bin/mqbroker -c conf/dledger/broker-n0.conf &amp;<br>第一个Broker的配置文件是broker-n0.conf，第二个broker的配置文件可以是Broker-n1.conf，第三个Broker的配置文件可以是broker-n2.conf。</li>
<li>broker-n0.conf配置详解<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 这个是集群的名称，你整个broker集群都可以用这个名称</span><br><span class="line">brokerClusterName = RaftCluster</span><br><span class="line"># 这是Broker的名称，比如你有一个Master和两个Slave，那么他们的Broker名称必须是一样的，因为他们三个是一个分组，如果你有另外一组Master和两个Slave，你可以给他们起个别的名字，比如说RaftNode01</span><br><span class="line">brokerName=RaftNode00</span><br><span class="line"># 这个就是你的Broker监听的端口号，如果每台机器上就部署一个Broker，可以考虑就用这个端口号，不用修改</span><br><span class="line">listenPort=30911</span><br><span class="line"># 这里是配置NameServer的地址，如果你有很多个NameServer的话，可以在这里写入多个NameServer的地址</span><br><span class="line">namesrvAddr=127.0.0.1:9876;127.0.0.2:9876;</span><br><span class="line"># 下面两个目录是存放Broker数据的地方，你可以换成别的目录，类似于是/usr/local/rocketmq/node00之类的</span><br><span class="line">storePathRootDir=/tmp/rmqstore/node00</span><br><span class="line">storePathCommitLog=/tmp/rmqstore/node00/commitlog</span><br><span class="line"># 这个是非常关键的一个配置，就是是否启用DLeger技术，这个必须是true</span><br><span class="line">enableDLegerCommitLog=true</span><br><span class="line"># 这个一般建议和Broker名字保持一致，一个Master加两个Slave会组成一个Group</span><br><span class="line">dLegerGroup=RaftNode00</span><br><span class="line"># 这个很关键，对于每一组Broker，你得保证他们的这个配置是一样的，在这里要写出来一个组里有哪几个Broker，比如在这里假设有三台机器部署了Broker，要让他们作为一个组，那么在这里就得写入他们三个的ip地址和监听的端口号</span><br><span class="line">dLegerPeers=n0-127.0.0.1:40911;n1-127.0.0.1:40912;n2-127.0.0.1:40913</span><br><span class="line"># 这个是代表了一个Broker在组里的id，一般就是n0、n1、n2之类的，这个你得跟上面的dLegerPeers中的n0、n1、n2相匹配</span><br><span class="line">dLegerSelfId=n0</span><br><span class="line"># 这个是发送消息的线程数量，一般建议你配置成跟你的CPU核数一样，比如我们的机器假设是24核的，那么这里就修改成24核</span><br><span class="line">sendMessageThreadPoolNums=24</span><br></pre></td></tr></table></figure></li>
<li>最关键的是，Broker是分为多组的，每一组是三个Broker，一个Master和两个Slave。对每一组Broker，他们的Broker名称、Group名称都是一样的，然后你得给他们配置好一样的dLegerPeers（里面是组内三台Broker的地址）。然后他们得配置好对应的NameServer的地址，最后还有就是每个Broker有自己的ID，在组内是唯一的就可以了，比如说不同的组里都有一个ID为n0的Broker。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/11/RocketMQ/RocketMQ%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%94%9F%E4%BA%A7%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LY Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/11/RocketMQ/RocketMQ%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%94%9F%E4%BA%A7%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">RocketMQ（三）：高可用的消息中间件生产部署架构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-11 21:05:24" itemprop="dateCreated datePublished" datetime="2019-11-11T21:05:24+08:00">2019-11-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index">
                    <span itemprop="name">RocketMQ</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><h4 id="NameServer集群化部署，保证高可用性"><a href="#NameServer集群化部署，保证高可用性" class="headerlink" title="NameServer集群化部署，保证高可用性"></a>NameServer集群化部署，保证高可用性</h4><ul>
<li>可以部署在三台机器上，这样可以充分保证NameServer作为路由中心的可用性，哪怕是挂掉两台机器，只要有一个NameServer还在运行，就能保证MQ系统的稳定性。</li>
<li>每台NameServer实际上都会有完整的集群路由信息，包括所有的Broker节点信息，我们的数据信息，等等。所以只要任何一台NameServer存活下来，就可以保证MQ系统正常运行，不会出现故障。</li>
</ul>
</li>
<li><h4 id="基于Dledger的Broker主从架构部署（RocketMQ-4-5以后）"><a href="#基于Dledger的Broker主从架构部署（RocketMQ-4-5以后）" class="headerlink" title="基于Dledger的Broker主从架构部署（RocketMQ 4.5以后）"></a>基于Dledger的Broker主从架构部署（RocketMQ 4.5以后）</h4><ul>
<li>Dledger技术是要求至少得是一个Master带两个Slave，这样有三个Broke组成一个Group，也就是作为一个分组来运行。一旦Master宕机，他就可以从剩余的两个Slave中选举出来一个新的Master对外提供服务。</li>
<li>每个Broker（不论是Master和Slave）都会把自己注册到所有的NameServer上去。（* 注：图中没有画出Slave Broker注册到NameServer）<br><img src="https://s2.ax1x.com/2019/11/13/MYQVpT.png" alt="avatar"></li>
</ul>
</li>
<li><h4 id="Broker是如何跟NameServer进行通信的？"><a href="#Broker是如何跟NameServer进行通信的？" class="headerlink" title="Broker是如何跟NameServer进行通信的？"></a>Broker是如何跟NameServer进行通信的？</h4><ul>
<li>Broker会跟每个NameServer都建立一个TCP长连接，然后定时通过TCP长连接发送心跳请求过去。</li>
<li>各个NameServer就是通过跟Broker建立好的长连接不断收到心跳包，然后定时检查Broker有没有120s都没发送心跳包，来判定集群里各个Broker到底挂掉了没有。</li>
</ul>
</li>
<li><h4 id="使用MQ的系统都要多机器集群部署"><a href="#使用MQ的系统都要多机器集群部署" class="headerlink" title="使用MQ的系统都要多机器集群部署"></a>使用MQ的系统都要多机器集群部署</h4><ul>
<li>生产者还是消费者的系统，都应该多机器集群化部署，保证他自己本身作为生产者或者消费者的高可用性。</li>
</ul>
</li>
<li><h4 id="MQ的核心数据模型：Topic（数据集合）"><a href="#MQ的核心数据模型：Topic（数据集合）" class="headerlink" title="MQ的核心数据模型：Topic（数据集合）"></a>MQ的核心数据模型：Topic（数据集合）</h4><ul>
<li>作为数据集合存放不同类型的消息，比如说订单Topic，商品Topic，等等。</li>
</ul>
</li>
<li><h4 id="Topic作为一个数据集合是怎么在Broker集群里存储的？（分布式存储）"><a href="#Topic作为一个数据集合是怎么在Broker集群里存储的？（分布式存储）" class="headerlink" title="Topic作为一个数据集合是怎么在Broker集群里存储的？（分布式存储）"></a>Topic作为一个数据集合是怎么在Broker集群里存储的？（分布式存储）</h4><ul>
<li>创建Topic的时候指定让他里面的数据分散存储在多台Broker机器上，比如一个Topic里有1000万条数据，此时有2台Broker，那么就可以让每台Broker上都放500万条数据。</li>
<li>每个Broker在进行定时的心跳汇报给NameServer的时候，都会告诉NameServer自己当前的数据情况，比如有哪些Topic的哪些数据在自己这里，这些信息都是属于路由信息的一部分。<br><img src="https://s2.ax1x.com/2019/11/14/MYIJGd.png" alt="avatar"></li>
</ul>
</li>
<li><h4 id="生产者系统是如何将消息发送给Broker的？"><a href="#生产者系统是如何将消息发送给Broker的？" class="headerlink" title="生产者系统是如何将消息发送给Broker的？"></a>生产者系统是如何将消息发送给Broker的？</h4><ul>
<li>在发送消息之前，得先有一个Topic，然后在发送消息的时候，得指定你要发送到哪个Topic里面去。</li>
<li>跟NameServer建立一个TCP长连接，然后定时从他那里拉取到最新的路由信息，包括集群里有哪些Broker，集群里有哪些Topic，每个Topic都存储在哪些Broker上。</li>
<li>生产者系统自然就可以通过路由信息找到自己要投递消息的Topic分布在哪几台Broker上，此时可以根据负载均衡算法，从里面选择一台Broke机器出来，比如round robine轮询算法，或者是hash算法，都可以。Broker收到消息之后就会存储在自己本地磁盘里去。</li>
<li>生产者一定是投递消息到Master Broker的，然后Master Broker会同步数据给他的Slave Brokers，实现一份数据多份副本，保证Master故障的时候数据不丢失，而且可以自动把Slave切换为Master提供服务。<br><img src="https://s2.ax1x.com/2019/11/14/MtfZqO.png" alt="avatar"></li>
</ul>
</li>
<li><h4 id="消费者是如何从Broker上拉取消息的？"><a href="#消费者是如何从Broker上拉取消息的？" class="headerlink" title="消费者是如何从Broker上拉取消息的？"></a>消费者是如何从Broker上拉取消息的？</h4><ul>
<li>消费者系统其实跟生产者系统原理是类似的，他们也会跟NameServer建立长连接，然后拉取路由信息，接着找到自己要获取消息的Topic在哪几台Broker上，就可以跟Broker建立长连接，从里面拉取消息了。</li>
<li>消费者系统可能会从Master Broker拉取消息，也可能从Slave Broker拉取消息，都有可能。<br><img src="https://s2.ax1x.com/2019/11/14/Mtfzlt.png" alt="avatar"></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/09/RocketMQ/RocketMQ%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ABroker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LY Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/09/RocketMQ/RocketMQ%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ABroker/" class="post-title-link" itemprop="url">RocketMQ（二）：Broker的主从架构原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-09 20:40:10" itemprop="dateCreated datePublished" datetime="2019-11-09T20:40:10+08:00">2019-11-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index">
                    <span itemprop="name">RocketMQ</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><h4 id="Master-Broker是如何将消息同步给Slave-Broker的？"><a href="#Master-Broker是如何将消息同步给Slave-Broker的？" class="headerlink" title="Master Broker是如何将消息同步给Slave Broker的？"></a>Master Broker是如何将消息同步给Slave Broker的？</h4><ul>
<li>为了保证MQ的数据不丢失而且具备一定的高可用性，所以一般都是得将Broker部署成Master-Slave模式的，也就是一个Master Broker对应一个Slave Broker。然后Master需要在接收到消息之后，将数据同步给Slave，这样一旦Master Broker挂了，还有Slave上有一份数据。</li>
<li>RocketMQ的Master-Slave模式采取的是Slave Broker不停的发送请求到Master Broker去拉取消息。<br><img src="https://s2.ax1x.com/2019/11/13/MYnnoV.png" alt="avatar"></li>
</ul>
</li>
<li><h4 id="RocketMQ-实现读写分离了吗？"><a href="#RocketMQ-实现读写分离了吗？" class="headerlink" title="RocketMQ 实现读写分离了吗？"></a>RocketMQ 实现读写分离了吗？</h4><ul>
<li>有可能从Master Broker获取消息，也有可能从Slave Broker获取消息。</li>
<li>作为消费者的系统在获取消息的时候会先发送请求到Master Broker上去，请求获取一批消息，此时Master Broker是会返回一批消息给消费者系统的。然后Master Broker在返回消息给消费者系统的时候，会根据当时Master Broker的负载情况和Slave Broker的同步情况，向消费者系统建议下一次拉取消息的时候是从Master Broker拉取还是从Slave Broker拉取。</li>
</ul>
</li>
<li><h4 id="如果Slave-Broke挂掉了有什么影响？"><a href="#如果Slave-Broke挂掉了有什么影响？" class="headerlink" title="如果Slave Broke挂掉了有什么影响？"></a>如果Slave Broke挂掉了有什么影响？</h4><ul>
<li>因为消息写入全部是发送到Master Broker的，然后消息获取也可以走Master Broker，只不过有一些消息获取可能是从Slave Broker去走的。所以如果Slave Broker挂了，那么此时无论消息写入还是消息拉取，还是可以继续从Master Broke去走，对整体运行不影响。</li>
</ul>
</li>
<li><h4 id="如果Master-Broker挂掉了该怎么办？"><a href="#如果Master-Broker挂掉了该怎么办？" class="headerlink" title="如果Master Broker挂掉了该怎么办？"></a>如果Master Broker挂掉了该怎么办？</h4><ul>
<li>RocketMQ 4.5版本之前，都是用Slave Broker同步数据，尽量保证数据不丢失，但是一旦Master故障了，Slave是没法自动切换成Master的。</li>
<li>如果Master Broker宕机了，这时就得手动做一些运维操作，把Slave Broker重新修改一些配置，重启机器给调整为Master Broker。</li>
<li>Master-Slave模式不是彻底的高可用模式，他没法实现自动把Slave切换为Master</li>
</ul>
</li>
<li><h4 id="基于Dledger实现RocketMQ高可用自动切换（RocketMQ-4-5之后）"><a href="#基于Dledger实现RocketMQ高可用自动切换（RocketMQ-4-5之后）" class="headerlink" title="基于Dledger实现RocketMQ高可用自动切换（RocketMQ 4.5之后）"></a>基于Dledger实现RocketMQ高可用自动切换（RocketMQ 4.5之后）</h4><ul>
<li>把Dledger融入RocketMQ之后，就可以让一个Master Broker对应多个Slave Broker，也就是说一份数据可以有多份副本，比如一个Master Broker对应两个Slave Broker。</li>
<li>Master Broker宕机了，就可以在多个副本，也就是多个Slave中，通过Dledger技术和Raft协议算法进行leader选举，直接将一个Slave Broker选举为新的Master Broker，然后这个新的Master Broker就可以对外提供服务了。<br><img src="https://s2.ax1x.com/2019/11/13/MYMNoq.png" alt="avatar"></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/07/RocketMQ/RocketMQ%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ANameServer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LY Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/07/RocketMQ/RocketMQ%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ANameServer/" class="post-title-link" itemprop="url">RocketMQ（一）：NameServer</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-07 19:34:14" itemprop="dateCreated datePublished" datetime="2019-11-07T19:34:14+08:00">2019-11-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/RocketMQ/" itemprop="url" rel="index">
                    <span itemprop="name">RocketMQ</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><h4 id="RocketMQ整体架构图"><a href="#RocketMQ整体架构图" class="headerlink" title="RocketMQ整体架构图"></a>RocketMQ整体架构图</h4><ul>
<li><h5 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h5>负责去管理集群里所有Broker的信息，让使用MQ的系统可以通过他感知到集群里有哪些Broker。</li>
<li><h5 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h5>Broker集群，必须得在多台机器上部署这么一个集群，而且还得用主从架构实现数据多副本存储和高可用。</li>
<li><h5 id="ProducerClient"><a href="#ProducerClient" class="headerlink" title="ProducerClient"></a>ProducerClient</h5>用户部署的消息发布客户端。</li>
<li><h5 id="ConsumerClient"><a href="#ConsumerClient" class="headerlink" title="ConsumerClient"></a>ConsumerClient</h5>用户部署的消息订阅客户端。支持push和pull模型，支持广播模式和集群模式。<br><img src="https://s2.ax1x.com/2019/11/06/MCwFtP.png" alt="avatar"></li>
</ul>
</li>
<li><h4 id="NameServer部署、注册、获取"><a href="#NameServer部署、注册、获取" class="headerlink" title="NameServer部署、注册、获取"></a>NameServer部署、注册、获取</h4><ul>
<li>多台服务器部署NameServer，保证高可用。</li>
<li>每个Broker启动都得向所有的NameServer进行注册，个NameServer都会有一份集群中所有Broker的信息。</li>
<li>生产者和消费者自己每隔一段时间，定时发送请求到NameServer去拉取最新的集群Broker信息。路由信息，每个系统就知道发送消息或者获取消息去哪台Broker上去进行了，这起到一个把消息路由到一个Broker上的效果，所以一般我们把这种信息叫做路由信息。</li>
</ul>
</li>
<li><h4 id="如果Broker挂了，NameServer是怎么感知到的？"><a href="#如果Broker挂了，NameServer是怎么感知到的？" class="headerlink" title="如果Broker挂了，NameServer是怎么感知到的？"></a>如果Broker挂了，NameServer是怎么感知到的？</h4><ul>
<li><strong>30s心跳机制：</strong> Broker跟NameServer之间的心跳机制，Broker会每隔30s给所有的NameServer发送心跳，告诉每个NameServer自己目前还活着。</li>
<li><strong>120s故障感知机制：</strong> NameServer会每隔10s运行一个任务，去检查一下各个Broker的最近一次心跳时间，如果某个Broker超过120s都没发送心跳了，那么就认为这个Broker已经挂掉了。</li>
</ul>
</li>
<li><h4 id="Broker挂了，系统是怎么感知到的？"><a href="#Broker挂了，系统是怎么感知到的？" class="headerlink" title="Broker挂了，系统是怎么感知到的？"></a>Broker挂了，系统是怎么感知到的？</h4><ul>
<li><strong>ProducerClient容错机制</strong><ul>
<li>改成发到其他Broker上去</li>
<li>与宕机的slave备份机器通信</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>  核心：集群化部署、Broker会注册到所有NameServer去、30s心跳机制和120s故障感知机制、生产者和消费者的客户端容错机制</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%E9%A1%B9%E7%9B%AE%E8%AE%A1%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LY Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%E9%A1%B9%E7%9B%AE%E8%AE%A1%E5%88%92/" class="post-title-link" itemprop="url">软件工程管理（三）项目计划</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-03 20:50:00" itemprop="dateCreated datePublished" datetime="2019-05-03T20:50:00+08:00">2019-05-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SoftwareManage/" itemprop="url" rel="index">
                    <span itemprop="name">SoftwareManage</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><h4 id="制定项目计划，三个基本步骤："><a href="#制定项目计划，三个基本步骤：" class="headerlink" title="制定项目计划，三个基本步骤："></a>制定项目计划，三个基本步骤：</h4><ul>
<li>任务分解<ul>
<li>大的阶段分成技术方案设计、编码和测试，然后每一个大的阶段下面再进一步细分。</li>
<li>例如技术方案设计下面再有需求分析、技术方案设计和评审等；而编码阶段则是按照功能模块再进一步拆分。拆分之后，都是小而具体、可交付结果的任务，且不能再进一步拆分。</li>
</ul>
</li>
<li>估算时间<ul>
<li>任务拆分的越细致，想的越清楚，就能估算的越准确。</li>
<li>要让负责这个任务的人员参与估算。</li>
</ul>
</li>
<li>排任务路径<ul>
<li>排路径就是要根据任务之间的关系，资源的占用情况，排出合适的顺序</li>
<li>排路径是一个相对比较复杂的任务，比如要注意任务的依赖关系，要注意路径的长度，尽可能让几个任务可以并行的进行，避免相互等待。</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="设置里程碑"><a href="#设置里程碑" class="headerlink" title="设置里程碑"></a>设置里程碑</h4><ul>
<li>里程碑的时间点确定后，计划可以灵活调整，但里程碑一般不会轻易改变，因为里程碑代表着一份承诺。这对于项目成员来说，有两个重要的影响，一方面，成员会有很明显的来自 DeadLine 的进度压力，自古 DeadLine 就是第一生产力；另一方面，就是在里程碑完成后，大家会获得一种正面激励。</li>
</ul>
</li>
<li><h4 id="计划跟踪和调整"><a href="#计划跟踪和调整" class="headerlink" title="计划跟踪和调整"></a>计划跟踪和调整</h4><ul>
<li>跟踪进度的方式<ul>
<li>项目经理定期收集跟踪：有一个沟通确认的过程，对进度会了解的更准确。</li>
<li>项目成员主动汇报：可以减少项目经理的收集工作，但有可能不准确。</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LY Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/" class="post-title-link" itemprop="url">软件工程管理（二）敏捷开发</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-03 20:11:08" itemprop="dateCreated datePublished" datetime="2019-05-03T20:11:08+08:00">2019-05-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SoftwareManage/" itemprop="url" rel="index">
                    <span itemprop="name">SoftwareManage</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><h4 id="什么是敏捷开发"><a href="#什么是敏捷开发" class="headerlink" title="什么是敏捷开发"></a>什么是敏捷开发</h4>  敏捷不是一种方法论，也不是一种软件开发的具体方法，更不是一个框架或过程，而是一套价值观和原则。<br>  用敏捷开发的方式，不再像瀑布模型那样有严格的阶段划分，会在迭代中不断完善；不再写很多文档，而是和客户一起紧密合作；不再抵制需求变更，而是即时响应变更；不再等到测试阶段才发布，而是随时发布，客户随时可以看到东西。<br>  敏捷开发的模式也存在一些问题，例如全程需要客户参与，由于测试相对少一些 ，问题也会相应多一些。</li>
<li><h4 id="敏捷开发和瀑布模型的差异"><a href="#敏捷开发和瀑布模型的差异" class="headerlink" title="敏捷开发和瀑布模型的差异"></a>敏捷开发和瀑布模型的差异</h4><ul>
<li>敏捷开发是怎么做需求分析的<ul>
<li>瀑布模型的一个重要阶段就是需求分析，要有严谨的需求分析，产生详尽的需求分析文档。</li>
<li>而敏捷开发的需求，主要是来源于一个个小的用户故事，用户故事通常是写在卡片上的一句话，在 Sprint 的开发中，再去确认需求的细节。</li>
<li>好处是减少了大量需求文档的撰写，可以早些进入开发。但这个对开发人员在需求理解和沟通的能力上要求更高了。</li>
</ul>
</li>
<li>敏捷开发是怎么做架构设计的<ul>
<li>瀑布模型在需求分析完了以后，就需要根据需求做架构设计。</li>
<li>而在敏捷开发中，并不是基于完整的用户需求开发，每个 Sprint 只做一部分需求，所以是一种渐进式的架构设计，当前 Sprint 只做适合当前需求的架构设计。</li>
<li>这种渐进式的架构设计，迭代次数一多，就会出现架构满足不了需求的现象，产生不少冗余代码，通常我们叫它技术债务，需要定期对系统架构进行重构。</li>
</ul>
</li>
<li>敏捷开发怎么保证项目质量的<ul>
<li>瀑布模型在编码完成后，会有专门的阶段进行测试，以保证质量。</li>
<li>在敏捷开发的 Sprint 中，并没有专门的测试阶段，这就依赖于开发功能的同时，要编写单元测试和集成测试代码，用自动化的方式辅助完成测试。</li>
</ul>
</li>
<li>敏捷开发是怎么发布部署的<ul>
<li>瀑布模型通常在编码结束后，开始部署测试环境，然后在测试阶段定期部署测试环境。测试验收通过后，发布部署到生产环境。</li>
<li>在敏捷开发中，这种持续构建、持续发布的概念叫持续集成，因为整个过程都是全自动化的，每次完成一个任务，提交代码后都可以触发一次构建部署操作，脚本会拿最新的代码做一次全新的构建，然后运行所有的单元测试和集成测试代码，测试通过后部署到测试环境。</li>
</ul>
</li>
<li><h4 id="敏捷开发的-Sprint-和迭代模型的迭代有什么区别"><a href="#敏捷开发的-Sprint-和迭代模型的迭代有什么区别" class="headerlink" title="敏捷开发的 Sprint 和迭代模型的迭代有什么区别"></a>敏捷开发的 Sprint 和迭代模型的迭代有什么区别</h4><ul>
<li>我们假设有两个团队，都要实现一个简单的用户系统，一个团队用迭代模型，一个团队用敏捷开发（Scrum），一个迭代 /Sprint 的时间周期都是 2 周（10 个工作日）。</li>
<li>迭代模型所在的团队，产品经理会先花 2 天时间去分析需求，写成需求分析文档，架构师会花 3 天时间来做设计，程序员会花 3 天时间编码，测试再花 2 天时间去测试，最后上线用户系统。</li>
<li>敏捷开发的团队，产品经理会把需求拆分成了几个简单的用户故事：用户登录、用户注册、找回密码、修改资料，然后放到当前 Sprint 的 Backlog（任务清单），Team（开发团队）成员开始从 Backlog 选择用户故事。<ul>
<li>程序员 A 选了“用户登录”这个用户故事，他会去找产品经理确认需求细节，之后动手实现这个用户故事。</li>
<li>功能完成后，同时程序员 A 还写了单元测试代码和集成测试代码，对登录的功能写了自动化测试。完成后，通过持续集成工具测试和部署到测试环境。部署完成后，用户登录功能就可以进行使用了。</li>
<li>这个过程，程序员 A 可能花了 4 天时间，做完“用户登录”这个用户故事之后，他又开始继续选取“找回密码”的用户故事来做，4 天时间也完成了。</li>
<li>其他程序员也和程序员 A 一样，他们也会从 Backlog 选择一些用户故事来做。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LY Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">软件工程管理（一）瀑布模型</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-02 00:34:14" itemprop="dateCreated datePublished" datetime="2019-05-02T00:34:14+08:00">2019-05-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SoftwareManage/" itemprop="url" rel="index">
                    <span itemprop="name">SoftwareManage</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><h4 id="瀑布模型把整个项目过程分成了六个主要阶段"><a href="#瀑布模型把整个项目过程分成了六个主要阶段" class="headerlink" title="瀑布模型把整个项目过程分成了六个主要阶段"></a>瀑布模型把整个项目过程分成了六个主要阶段</h4><ul>
<li>问题的定义及规划<br>需求方和开发方共同确定软件开发目标，同时还要做可行性研究，以确定项目可行。这个阶段会产生需求文档和可行性研究报告。</li>
<li>需求分析<br>对需求方提出的所有需求，进行详细的分析。这个阶段一般需要和客户反复确认，以保证能充分理解客户需求。最终会形成需求分析文档。</li>
<li>软件设计<br>根据需求分析的结果，对整个软件系统进行抽象和设计，如系统框架设计，数据库设计等等。最后会形成架构设计文档。</li>
<li>程序编码<br>将架构设计和界面设计的结果转换成计算机能运行的程序代码。</li>
<li>软件测试<br>对可运行的结果对照需求分析文档进行严密的测试。</li>
<li>运行维护<br>在软件开发完成，正式运行投入使用。后续需要继续维护，修复错误和增加功能。交付时需要提供使用说明文档。</li>
</ul>
</li>
<li><h4 id="瀑布模型优点"><a href="#瀑布模型优点" class="headerlink" title="瀑布模型优点"></a>瀑布模型优点</h4><ul>
<li>简单易行</li>
<li>可以按照阶段检查，能及时发现问题</li>
<li>前一个阶段完成后，就可以重点关注下一个阶段</li>
<li>有很好的分工协作</li>
<li>对质量有保证</li>
</ul>
</li>
<li><h4 id="瀑布模型缺点"><a href="#瀑布模型缺点" class="headerlink" title="瀑布模型缺点"></a>瀑布模型缺点</h4><ul>
<li>难以响应需求的变更，当需求发生改变的时候，越到后期代价越大</li>
<li>工作量分布不均匀。例如前期开发，测试人员无法参与，而后期开发，测试人员又特别忙</li>
<li>前期进度受阻，会一只压缩后续阶段时间，导致延期或影响质量</li>
<li>一直到最后阶段才能看到结果</li>
</ul>
</li>
<li><h4 id="瀑布模型以外的开发模型"><a href="#瀑布模型以外的开发模型" class="headerlink" title="瀑布模型以外的开发模型"></a>瀑布模型以外的开发模型</h4><ul>
<li>快速开发快速改：先迅速建造一个可以运行的软件原型，然后收集用户反馈，再反复修改确认</li>
<li>大瀑布拆小瀑布：系统进行模块化处理，分批次交付软件产品</li>
<li>迭代模型：每次迭代都有一个可用的版本</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/19/Maven/Maven(%E4%B8%80)%EF%BC%9A%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE%E3%80%81mvn%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LY Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/19/Maven/Maven(%E4%B8%80)%EF%BC%9A%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE%E3%80%81mvn%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">Maven(一)：安装、配置</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-19 00:34:14" itemprop="dateCreated datePublished" datetime="2019-04-19T00:34:14+08:00">2019-04-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Maven/" itemprop="url" rel="index">
                    <span itemprop="name">Maven</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>安装jdk<ul>
<li>oracle官网上去下载jdk-8u181-linux-x64.tar.gz，将其放在/opt/jdk目录中，并解压<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zvxf jdk-8u181-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></li>
<li>配置环境变量，在/etc/profile文件末尾追加下面几行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/jdk/jdk1.8.0_181</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure></li>
<li>配置生效<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li>
<li>验证jdk是否正常<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>安装maven<ul>
<li>下载地址 <a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">https://maven.apache.org/download.cgi</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /opt/maven</span><br><span class="line">cd /opt/maven/</span><br><span class="line">wget http://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.2/binaries/apache-maven-3.6.2-bin.tar.gz</span><br><span class="line">tar -zvxf apache-maven-3.6.2-bin.tar.gz</span><br></pre></td></tr></table></figure></li>
<li>配置maven环境变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export M2_HOME=/opt/maven/maven</span><br><span class="line">export PATH=$M2_HOME/bin:$PATH</span><br></pre></td></tr></table></figure></li>
<li>配置生效<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li>
<li>验证maven<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/01/22/JVM/JVM%E7%B3%BB%E5%88%97(%E4%B8%89)%EF%BC%9AJVM%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%EF%BC%8C%E5%88%86%E5%88%AB%E9%83%BD%E6%98%AF%E7%94%A8%E6%9D%A5%E5%B9%B2%E5%98%9B%E7%9A%84%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LY Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2015/01/22/JVM/JVM%E7%B3%BB%E5%88%97(%E4%B8%89)%EF%BC%9AJVM%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%EF%BC%8C%E5%88%86%E5%88%AB%E9%83%BD%E6%98%AF%E7%94%A8%E6%9D%A5%E5%B9%B2%E5%98%9B%E7%9A%84%EF%BC%9F/" class="post-title-link" itemprop="url">JVM系列(三)：JVM中有哪些内存区域，分别都是用来干嘛的？</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-01-22 00:34:14" itemprop="dateCreated datePublished" datetime="2015-01-22T00:34:14+08:00">2015-01-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="到底什么是JVM的内存区域划分"><a href="#到底什么是JVM的内存区域划分" class="headerlink" title="到底什么是JVM的内存区域划分"></a>到底什么是JVM的内存区域划分</h4><ul>
<li>那么运行方法的时候，方法里面有很多变量之类的东西，是不是需要放在某个内存区域里？</li>
<li>接着如果我们写的代码里创建一些对象，这些对象是不是也需要内存空间来存放？</li>
<li>这就是为什么JVM中必须划分出来不同的内存区域，它是为了我们写好的代码在运行过程中根据需要来使用的。<br><img src="https://mubu.com/document_image/b7b54e87-506a-46e1-bede-55845919dc71-4276170.jpg" alt="avatar"><h4 id="存放类的方法区"><a href="#存放类的方法区" class="headerlink" title="存放类的方法区"></a>存放类的方法区</h4></li>
<li>主要是放从“.class”文件里加载进来的类，还会有一些类似常量池的东西放在这个区域里。<h4 id="执行代码指令用的程序计数器"><a href="#执行代码指令用的程序计数器" class="headerlink" title="执行代码指令用的程序计数器"></a>执行代码指令用的程序计数器</h4></li>
<li>我们写好的Java代码（.java）会被翻译成字节码(.class)，对应各种字节码指令</li>
<li>字节码指令一定会被一条一条执行，这样才能实现我们写好的代码执行的效果</li>
<li>那么在执行字节码指令的时候，JVM里就需要一个特殊的内存区域了，那就是“程序计数器”</li>
<li>大家都知道JVM是支持多个线程的，所以其实你写好的代码可能会开启多个线程并发执行不同的代码，所以就会有多个线程来并发的执行不同的代码指令</li>
<li>因此每个线程都会有自己的一个程序计数器，专门记录当前这个线程目前执行到了哪一条字节码指令了<br><img src="https://mubu.com/document_image/91747429-c1c5-4fe2-95b7-6b8ae9d04571-4276170.jpg" alt="avatar"><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4></li>
<li>因此，JVM必须有一块区域是来保存每个方法内的局部变量等数据的，这个区域就是Java虚拟机栈</li>
<li>每个线程都有自己的Java虚拟机栈</li>
<li>在栈帧里存放了这个方法对应的局部变量之类的数据，包括这个方法执行的其他相关的信息，方法执行完毕之后就出栈。<br><img src="https://mubu.com/document_image/9f97e9a9-24b1-4944-a4af-8fc8e34e8ab6-4276170.jpg" alt="avatar"></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/01/19/JVM/JVM%E7%B3%BB%E5%88%97(%E4%BA%8C)%EF%BC%9AJVM%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘勇">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LY Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2015/01/19/JVM/JVM%E7%B3%BB%E5%88%97(%E4%BA%8C)%EF%BC%9AJVM%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">JVM系列(二)：JVM 类加载机制</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-01-19 00:34:14" itemprop="dateCreated datePublished" datetime="2015-01-19T00:34:14+08:00">2015-01-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="JVM在什么情况下会加载一个类？"><a href="#JVM在什么情况下会加载一个类？" class="headerlink" title="JVM在什么情况下会加载一个类？"></a>JVM在什么情况下会加载一个类？</h4><ul>
<li>代码使用到这个类的时候才会把类加载到JVM内存中，一个类从加载到使用，经历过程：加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载<h4 id="从实用角度出发，来看看验证、准备和初始化的过程"><a href="#从实用角度出发，来看看验证、准备和初始化的过程" class="headerlink" title="从实用角度出发，来看看验证、准备和初始化的过程"></a>从实用角度出发，来看看验证、准备和初始化的过程</h4></li>
<li>验证：简单来说，这一步就是根据Java虚拟机规范，来校验加载进来的“.class”文件中的内容，是否符合指定的规范。</li>
<li>准备：<ul>
<li>假设你有这么一个“ReplicaManager”类，他的“ReplicaManager.class”文件内容刚刚被加载到内存之后，会进行验证，确认这个字节码文件的内容是规范的。</li>
<li>这个准备工作，其实就是给这个“ReplicaManager”类分配一定的内存空间。然后给他里面的类变量（也就是static修饰的变量）分配内存空间，来一个默认的初始值。</li>
<li>解析：符号引用替换为直接引用，内容很复杂，涉及JVM底层</li>
</ul>
</li>
</ul>
<h4 id="核心阶段：初始化"><a href="#核心阶段：初始化" class="headerlink" title="核心阶段：初始化"></a>核心阶段：初始化</h4><ul>
<li>什么时候会初始化一个类？<ul>
<li>一般来说有以下一些时机：比如“new ReplicaManager()”来实例化类的对象了，此时就会触发类的加载到初始化的全过程，把这个类准备好，然后再实例化一个对象出来。或者是包含“main()”方法的主类，必须是立马初始化的。</li>
<li>此外，这里还有一个非常重要的规则，就是如果初始化一个类的时候，发现他的父类还没初始化，那么必须先初始化他的父类。</li>
</ul>
</li>
</ul>
<h4 id="类加载器和双亲委派机制"><a href="#类加载器和双亲委派机制" class="headerlink" title="类加载器和双亲委派机制"></a>类加载器和双亲委派机制</h4><ul>
<li><p>类加载器</p>
<ul>
<li>启动类加载器：Bootstrap ClassLoader，他主要是负责加载我们在机器上安装的Java目录下的核心类的，所以一旦你的JVM启动，那么首先就会依托启动类加载器，去加载你的Java安装目录下的“lib”目录中的核心类库。</li>
</ul>
</li>
<li><p>扩展类加载器</p>
<ul>
<li>这个类加载器其实也是类似的，就是你的Java安装目录下，有一个“lib\ext”目录</li>
</ul>
</li>
<li><p>应用程序类加载器</p>
<ul>
<li>其实你大致就理解为去加载你写好的Java代码吧，这个类加载器就负责加载你写好的那些类到内存里。</li>
</ul>
</li>
<li><p>自定义类加载器</p>
<ul>
<li>根据自己的需求加载类</li>
</ul>
</li>
<li><p>双亲委派机制</p>
<ul>
<li>JVM的类加载器是有亲子层级结构的，就是说启动类加载器是最上层的，扩展类加载器在第二层，第三层是应用程序类加载器，最后一层是自定义类加载器。基于亲子层级结构，就有一个双亲委派的机制</li>
<li>应用程序类加载器在自己负责的范围内，比如就是你写好的那个系统打包成的jar包吧，一下子发现，就在这里！然后就自己把这个类加载到内存里去了。</li>
<li>先找父亲去加载，不行的话再由儿子来加载。（双亲委派机制）</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="刘勇"
    src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">刘勇</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘勇</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  


















  

  

  


  <script type="text/javascript" src="/js/src/dynamic_bg.js"></script>
  <script src="/lib/live2d/L2Dwidget.min.js"></script>
<script type="text/javascript">
  L2Dwidget.init({
    model: {
      jsonPath: '/lib/live2d/tororo/assets/tororo.model.json',
    },
    display: {
      superSample: 2,
      width: 100,
      height: 100,
      position: 'right',
      hOffset: 0,
      vOffset: 0,
    },
    mobile: {
      show: true,
      scale: 1,
      motion: true,
    },
    react: {
      opacityDefault: 0.8,
      opacityOnHover: 0.2,
    }
  })
</script>

</body>
</html>
